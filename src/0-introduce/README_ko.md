# eBPF Tutorial by Example 0: Introduction to Core Concepts and Tools

## Introduction to eBPF: Secure and Efficient Kernel Extension

eBPF는 Linux Kernel에서 파생되었으며, 샌드박스 프로그램이 커널 레벨에서 실행될 수 있도록 허용하는 혁명적인 기술이다. 이는 커널 모듈을 커널에 로드하거나 커널 소스 코드를 수정할 필요 없이, 안전하고 효율적으로 커널의 기능을 확장하는데 사용된다. eBPF는 애플리케이션 개발자가 OS에 추가적인 기능을 동적으로 추가할 수 있게 한다. OS는 Just-In_Time(JIT) 컴파일러와 검증 엔진의 도움을 받아 실행할 프로그램의 안전성과 효율성을 검증한다. eBPF 프로그램은 커널 버전에 종속되지 않으며, 자동으로 업데이트될 수 있어 노드를 재시작할 필요가 없기 때문에 실행 중인 워크로드에 영향을 미치지 않는다.

오늘날, eBPF는 현대 데이터 센터 및 클라우드 네이티브 환경 등에서 다양한 시나리오로 널리 사용되고 있다.

- 고성능의 네트워크 패킷 처리 및 로드 밸런싱
- 낮은 리소스 오버헤드로 세분화된 시스템 관찰
- 애플리케이션 추적을 통해 troubleshooting에 대한 통찰력 제공

## The Future of eBPF: Kernel's JavaScript Programmable Interface

Javascript와 유사하게 eBPF 또한 운영체제 위에서 프로그래밍 기능을 제공한다. eBPF를 통해 만든 프로그램은 리눅스 커널 위에서 실행되기 때문에, 효율적인 프로그래밍을 위해 리눅스 커널의 구조를 잘 알아야 한다.

![kernel-arch](kernel-arch.png)

리눅스 커널의 주 목적은 하드웨어 혹은 가상 하드웨어를 가상화하고 일관된 API를 제공하여 애플리케이션이 실행되고 자원을 공유할 수 있도록 하는 것이다. 이 목적을 달성하기 위해 시스템을 계층화하여 여러 서브시스템으로 책임을 분배한다. 각 서브시스템은 사용자의 요구를 충족하기 위한 어느 정도의 설정 변환을 허용한다. 하지만 만일 허용되는 설정을 통해 원하는 동작을 얻어낼 수 없다면, 아래의 방법을 통해 얻어낼 수 있다.

- 커널 소스 코드 직접 수정: 난이도 극상
- 커뮤니티 공유: 느린 피드백
- 커널 모듈 개발: 커널 버전에 맞춰 지속적인 코드 수정 필요

위 방법들에 비해 eBPF는 우월하다.

- 커널의 소스 코드를 수정할 필요 없다.
- 커널 모듈을 로드할 필요 없다
- 커널 버전에 종속되지 않고 일정 레벨의 일관된 동작 및 안전성을 보장한다.

eBPF 프로그램이 실행되는 eBPF 가상 머신 또한 시스템 콜과 유사한 메카니즘을 제공한다. 즉, 프로그래밍을 위한 API를 제공한다.

![new-os](new-os-model.png)

오늘날의 리눅스 커널은 진화하고 있다. 사용자 정의 애플리케이션은 user space와 kernel space에서 모두 실행될 수 있으며, user space에서는 전통적인 시스템 콜 호출을 통해 시스템 리소스에 접근하고 kernel space에서는 BPF Helper Call을 통해 시스템의 여러 부분과 상호 작용한다. 2023년 초 기준 커널의 eBPF 가상 머신에는 이미 220개 이상의 Helper 시스템 인터페이스가 존재하며 광범위한 애플리케이션 시나리오를 다루고 있다. syscall과 BPF Helper Call은 경쟁 관계가 아니다.

현재 eBPF는 아직 초기 단계에 있습니다. 그러나 eBPF가 제공하는 커널 인터페이스와 사용자 공간과의 상호 작용 기능의 도움으로 Wasm 가상 머신의 응용 프로그램은 거의 모든 커널 또는 사용자 모드 함수 호출(kprobe, routbe...)의 데이터 및 반환 값에 액세스할 수 있습니다. 낮은 비용으로 모든 시스템 호출을 수집하고 이해할 수 있으며 모든 네트워크 작업에 대한 패킷 수준 데이터와 소켓 수준 데이터를 얻을 수 있습니다(tracepoint, socket...). 또한 추가 프로토콜 분석기를 추가할 수 있으며 리눅스 커널의 패킷 처리 환경을 벗어나지 않고 네트워크 패킷 처리 솔루션에 모든 포워딩 로직을 쉽게 프로그래밍할 수 있습니다(XDP, TC...).

커널 모드 eBPF 런타임 외에도 eBPF를 사용자 공간으로 확장하여 더 높은 성능의 사용자 공간 추적, 성능 분석, 플러그인 등을 달성할 수 있습니다.

## Some Tips on Learning eBPF Development

llvm은 고급 언어로 작성된 코드를 eBPF 바이트코드로 컴파일하는 기능이 2015년에 소개했다. 그리고 eBPF 커뮤니티는 기존의 시스템 콜들을 wrap하여 libbpf 라이브러리를 제공했다.

전형적인 libbpf-based eBPF 프로그램은 2개의 파일로 구성된다. 

- `*_kern.c`: mounting point 및 커널에서 실행될 함수 정의
- `*_user.c`: 커널 코드 주입을 위한 코드 및 user space에서의 다양한 작업 정의

그럼에도 불구하고 진입장벽이 높기 때문에 최근에는 다양한 툴들의 도움을 받아 개발한다.

## Writing eBPF programs

eBPF 프로그램은 커널 공간 부분과 사용자 공간 부분으로 구성되어 있습니다. 커널 공간 부분은 프로그램의 실제 로직을 포함하고 사용자 공간 부분은 커널 공간 부분의 로딩과 관리를 담당합니다. eunomia-bpf 개발 툴을 사용하면 커널 공간 부분만 작성하면 됩니다.

커널 공간 부분의 코드는 eBPF의 구문과 명령어 집합을 따를 필요가 있습니다. eBPF 프로그램은 주로 여러 함수들로 구성되며, 각각의 고유한 목적을 가지고 있습니다. 사용 가능한 함수 유형은 다음과 같습니다:

kprobe: 지정된 커널 함수 이전 또는 이후에 실행되는 프로브 함수.
트레이스포인트: 지정된 커널 트레이스포인트에서 실행되는 트레이스포인트 함수.
raw_trace 포인트: raw 추적 포인트 함수, 지정된 커널 원시 추적 포인트에서 실행됩니다.
xdp: 네트워크 데이터 처리 기능, 네트워크 패킷을 가로채고 처리합니다.
perf_event: 커널 성능 이벤트를 처리하는 데 사용되는 성능 이벤트 함수입니다.
kretprobe: 반환 프로브 함수, 지정된 커널 함수가 반환될 때 실행됩니다.
tracepoint_return: 지정된 커널 추적점이 반환될 때 실행되는 추적점 반환 함수.
raw_tracepoint_return: raw 추적점 반환 함수, 지정된 커널 원시 추적점이 반환될 때 실행됩니다.

